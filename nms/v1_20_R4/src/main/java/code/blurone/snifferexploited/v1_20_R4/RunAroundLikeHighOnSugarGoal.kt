package code.blurone.snifferexploited.v1_20_R4

import code.blurone.snifferexploited.v1_20_R4.HighOnSugar.Companion.HIGH_ON_SUGAR_META_NAME
import net.minecraft.world.entity.ai.goal.Goal
import net.minecraft.world.entity.ai.util.DefaultRandomPos
import net.minecraft.world.phys.Vec3
import org.bukkit.entity.Sniffer
import org.bukkit.inventory.ItemStack
import org.bukkit.plugin.Plugin
import java.util.*
import kotlin.random.Random

class RunAroundLikeHighOnSugarGoal(
    private val sniffer: net.minecraft.world.entity.animal.sniffer.Sniffer,
    private val timeBeforeExploding: Int,
    private val pacificExplosion: Boolean,
    private val minFire: Int,
    private var potionDropChance: Double,
    private var explosionChance: Double,
    private var speedModifier: Double,
    private val plugin: Plugin,
    private val createPotion: () -> ItemStack
) : Goal() {
    init {
        flags = EnumSet.of(Flag.MOVE)
    }
    
    private val bukkitSniffer = sniffer.bukkitEntity as Sniffer
    private var posX = 0.0
    private var posY = 0.0
    private var posZ = 0.0
    private var ticksLeft = timeBeforeExploding
    private var timesUpgraded = 0
    private var explosionAmount = if (pacificExplosion) 0f else 2f
    private var shallFire = { minFire in 1..timesUpgraded && !pacificExplosion }
    var started = false
    private val otherGoals = sniffer.goalSelector.availableGoals.filter { it.goal !is RunAroundLikeHighOnSugarGoal }.toSet()

    override fun canUse(): Boolean = true

    override fun start() {
        newRandomBlock()
        started = true
    }

    override fun canContinueToUse(): Boolean = true

    override fun tick() {
        if (ticksLeft-- <= 0 || sniffer.fallDistance >= 5) explode()

        for (goal in sniffer.goalSelector.availableGoals)
            if (goal.goal != this)
                sniffer.goalSelector.removeGoal(goal)

        newRandomBlock()
        bukkitSniffer.state = Sniffer.State.DIGGING
        if (sniffer.navigation.isStuck) explode()
    }

    private fun explode() {
        sniffer.navigation.stop()
        val shallExplode = Random.nextDouble() < explosionChance
        if (shallExplode)
            bukkitSniffer.world.createExplosion(bukkitSniffer.location, explosionAmount, shallFire(), !pacificExplosion, bukkitSniffer)

        if (Random.nextDouble() < potionDropChance)
            bukkitSniffer.world.dropItem(bukkitSniffer.location, createPotion())

        if (shallExplode)
            return bukkitSniffer.remove()

        sniffer.goalSelector.removeGoal(this)
        bukkitSniffer.removeMetadata(HIGH_ON_SUGAR_META_NAME, plugin)

        for (wrappedGoal in otherGoals)
            sniffer.goalSelector.addGoal(wrappedGoal.priority, wrappedGoal.goal)
    }

    private fun newRandomBlock() {
        var vec3d = DefaultRandomPos.getPos(sniffer, 8 * speedModifier.toInt() / 10, 2)
        if (vec3d == null) vec3d = Vec3(
            sniffer.x + sniffer.random.nextInt(-8 * speedModifier.toInt() / 10, 8 * speedModifier.toInt() / 10),
            sniffer.y,
            sniffer.z + sniffer.random.nextInt(-8 * speedModifier.toInt() / 10, 8 * speedModifier.toInt() / 10)
        )
        posX = vec3d.x
        posY = vec3d.y
        posZ = vec3d.z
        sniffer.navigation.moveTo(posX, posY, posZ, speedModifier)
    }

    fun potentiate() {
        if (!started) return

        ++timesUpgraded

        if (explosionAmount >= 8f)
            return explode()

        explosionAmount *= 2f
        speedModifier *= 2.0
        explosionChance *= 1.5
        potionDropChance *= 1.5
        ticksLeft = timeBeforeExploding
    }
}