package code.blurone.snifferexploited

import org.bukkit.*
import org.bukkit.configuration.ConfigurationSection
import org.bukkit.entity.*
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.BlockBreakEvent
import org.bukkit.event.entity.AreaEffectCloudApplyEvent
import org.bukkit.event.entity.LingeringPotionSplashEvent
import org.bukkit.event.entity.PotionSplashEvent
import org.bukkit.event.inventory.BrewEvent
import org.bukkit.event.player.PlayerItemConsumeEvent
import org.bukkit.inventory.ItemFlag
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.PotionMeta
import org.bukkit.persistence.PersistentDataType
import org.bukkit.plugin.java.JavaPlugin
import org.bukkit.potion.PotionEffect
import org.bukkit.potion.PotionEffectType
import org.bukkit.scheduler.BukkitRunnable
import org.bukkit.util.Transformation
import org.joml.Vector3f

class PotionOfSniffing(private val plugin: JavaPlugin, config: ConfigurationSection) : Listener {
    companion object {
        fun isSniffingPotion (itemStack: ItemStack): Boolean =
            itemStack.itemMeta?.persistentDataContainer?.has(sniffingPotionNamespacedKey) == true
            //(itemStack.type == Material.POTION || itemStack.type == Material.SPLASH_POTION || itemStack.type == Material.LINGERING_POTION) && itemStack.itemMeta!!.persistentDataContainer.has(sniffingPotionNamespacedKey)

        fun createPotion(potionVariant: String = "potion"): ItemStack {
            return createPotion(when(potionVariant) {
                "splash" -> 1
                "lingering" -> 2
                else -> 0
            })
        }

        private fun createPotion(potionVariant: Int = 0): ItemStack {
            val potion = ItemStack(when(potionVariant) {
                1 -> Material.SPLASH_POTION
                2 -> Material.LINGERING_POTION
                else -> Material.POTION
            })
            val meta = potion.itemMeta as PotionMeta
            meta.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, potionVariant)
            meta.setDisplayName("ยงr${when(potionVariant) {
                1 -> OcdTranslator.DEFAULT_SPLASH_NAME
                2 -> OcdTranslator.DEFAULT_LINGERING_NAME
                else -> OcdTranslator.DEFAULT_POTION_NAME
            }}")
            meta.lore = listOf("ยง9${OcdTranslator.DEFAULT_INFO}")
            meta.color = Color.fromRGB(0xffbf23)
            meta.addItemFlags(ItemFlag.HIDE_POTION_EFFECTS)
            meta.setCustomModelData(customModelData)
            potion.itemMeta = meta
            return potion
        }

        private lateinit var sniffingPotionNamespacedKey : NamespacedKey
        private var customModelData : Int? = null
    }

    init {
        sniffingPotionNamespacedKey = NamespacedKey(plugin, "sniffing_potion")
        customModelData = config.get("custom_model_data") as? Int
    }

    // MutableMap<Location#toString, Display>
    private val displayMap: MutableMap<String, Display> = mutableMapOf()
    private val viewersMap: MutableMap<Display, Int> = mutableMapOf()
    private val shallLog = config.getBoolean("sniff_logging", true)
    private val oreSniffingMode = config.getString("ore_sniffing_mode", "block")
    private val worlds = config.getConfigurationSection("enabled_worlds")
    private val lookupBlocks = // Look at the stars!!! How cute :3
        Tag.COAL_ORES.values                               +
        Tag.IRON_ORES.values        +
        Tag.COPPER_ORES.values                                                       +
        Tag.GOLD_ORES.values                         +
        Tag.REDSTONE_ORES.values                                                                    +
        Tag.EMERALD_ORES.values                                   +
        Tag.LAPIS_ORES.values                +
        Tag.DIAMOND_ORES.values                                                    +
        setOf(Material.ANCIENT_DEBRIS, Material.NETHER_QUARTZ_ORE, Material.BUDDING_AMETHYST)

    @EventHandler
    private fun drinkSniffingPotionEvent(event: PlayerItemConsumeEvent) {
        if (isSniffingPotion(event.item))
            scanForOres(event.player)
    }

    @EventHandler
    private fun splashingSniffingPotionEvent(event: PotionSplashEvent) {
        if (!isSniffingPotion(event.potion.item)) return

        for (entity in event.affectedEntities) {
            val intensity = event.getIntensity(entity)
            if (entity !is Player)
                entity.world.playSound(
                    entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f,
                    (1.5 - 0.25 * intensity).toFloat()
                )
            else
                scanForOres(entity, ((worlds?.getInt("${entity.world.name}.radius") ?: 16)*intensity).toInt())
        }
    }

    @EventHandler
    private fun lingeringSniffingCloudCreateEvent(event: LingeringPotionSplashEvent) {
        if (!isSniffingPotion(event.entity.item)) return

        event.areaEffectCloud.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, 2)
        event.areaEffectCloud.addCustomEffect(PotionEffect(
            PotionEffectType.LUCK, 0, 1, false, false, false
        ), true)
        event.areaEffectCloud.color = Color.fromRGB(0xffbf23)
    }

    @EventHandler
    private fun areaCloudSniffingEvent(event: AreaEffectCloudApplyEvent) {
        if (!event.entity.persistentDataContainer.has(sniffingPotionNamespacedKey))
            return

        for (entity in event.affectedEntities)
            if (entity !is Player)
                entity.world.playSound(entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, 1.5f)
            else
                scanForOres(entity, duration = (worlds?.getDouble("${entity.world.name}.duration") ?: 60.0)*0.25)
    }

    @EventHandler
    private fun brewSniffingPotionUpgradeEvent(event: BrewEvent) {
        val lookingForLevel = when (event.contents.ingredient?.type) {
            Material.GUNPOWDER -> 0
            Material.DRAGON_BREATH -> 1
            else -> return
        }

        for (i in 0..<event.contents.contents.size)
            if (event.contents.contents[i]?.itemMeta!!.persistentDataContainer.get(sniffingPotionNamespacedKey, PersistentDataType.INTEGER) == lookingForLevel)
                event.results[i].itemMeta = createPotion(lookingForLevel + 1).itemMeta
    }

    @EventHandler
    private fun killDisplayEvent(event: BlockBreakEvent) {
        val display = displayMap.remove(event.block.location.toString()) ?: return
        viewersMap.remove(display)
        display.remove()
    }

    fun scanForOres(
        player: Player,
        radius: Int = worlds?.getInt("${player.world.name}.radius") ?: 16,
        duration: Double = worlds?.getDouble("${player.world.name}.duration") ?: 60.0
    ) {
        if (radius <= 1) return

        if (shallLog)
            plugin.logger.info("${player.name} is sniffing for ores in a radius of $radius blocks for $duration seconds.")

        player.world.playSound(
            player, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f,
            (1.25 - 0.25 * radius / (worlds?.getInt("${player.world.name}.radius") ?: 16)).toFloat()
        )

        val playerBlock = player.location.block
        val addedLocations: MutableSet<String> = mutableSetOf()

        for (x in -radius..radius) for (y in -radius..radius) for (z in -radius..radius) {
            val block = playerBlock.getRelative(x, y, z)
            if (block.type !in lookupBlocks) continue

            val display: Display = displayMap[block.location.toString()] ?: (
                if (oreSniffingMode == "block")
                    (player.world.spawnEntity(block.location, EntityType.BLOCK_DISPLAY, false) as BlockDisplay).apply {
                        transformation = Transformation(
                            Vector3f(1f),
                            transformation.leftRotation,
                            Vector3f(-1f),
                            transformation.rightRotation
                        )
                        this.block = block.blockData
                    }
                else
                    (player.world.spawnEntity(
                        block.location.add(0.5, 0.5, 0.5),
                        EntityType.ITEM_DISPLAY, false
                    ) as ItemDisplay).apply {
                        val raw = oreSniffingMode == "raw"
                        billboard = Display.Billboard.CENTER
                        itemStack = ItemStack(when (block.type) {
                            in Tag.COAL_ORES.values -> Material.COAL
                            in Tag.IRON_ORES.values -> if (raw) Material.RAW_IRON else Material.IRON_INGOT
                            in Tag.COPPER_ORES.values -> if (raw) Material.RAW_COPPER else Material.COPPER_INGOT
                            Material.GOLD_ORE,
                            Material.DEEPSLATE_GOLD_ORE -> if (raw) Material.RAW_GOLD else Material.GOLD_INGOT
                            Material.NETHER_GOLD_ORE -> Material.GOLD_NUGGET
                            in Tag.REDSTONE_ORES.values -> Material.REDSTONE
                            in Tag.EMERALD_ORES.values -> Material.EMERALD
                            in Tag.LAPIS_ORES.values -> Material.LAPIS_LAZULI
                            in Tag.DIAMOND_ORES.values -> Material.DIAMOND
                            Material.NETHER_QUARTZ_ORE -> Material.QUARTZ
                            Material.ANCIENT_DEBRIS -> if (raw) Material.NETHERITE_SCRAP else Material.NETHERITE_INGOT
                            Material.BUDDING_AMETHYST -> Material.AMETHYST_SHARD
                            else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                        })
                    }
                ).apply {
                    displayHeight = 1f
                    displayWidth = 1f
                    isGlowing = true
                    isVisibleByDefault = false
                    glowColorOverride = when(block.type) {
                        in Tag.COAL_ORES.values     -> Color.fromRGB(0x2e2e2e)
                        in Tag.IRON_ORES.values     -> Color.fromRGB(0xd8af93)
                        in Tag.COPPER_ORES.values   -> Color.fromRGB(0xe0734d)
                        in Tag.GOLD_ORES.values     -> Color.fromRGB(0xeb9d0e)
                        in Tag.REDSTONE_ORES.values -> Color.fromRGB(0xff0000)
                        in Tag.EMERALD_ORES.values  -> Color.fromRGB(0x17dd62)
                        in Tag.LAPIS_ORES.values    -> Color.fromRGB(0x1855bd)
                        in Tag.DIAMOND_ORES.values  -> Color.fromRGB(0x77e7d1)
                        Material.NETHER_QUARTZ_ORE  -> Color.fromRGB(0xeae5de)
                        Material.ANCIENT_DEBRIS     -> Color.fromRGB(0x654740)
                        Material.BUDDING_AMETHYST   -> Color.fromRGB(0xa678f1)
                        else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                    }
                    displayMap[block.location.toString()] = this
                }

            player.showEntity(plugin, display)

            viewersMap[display] = (viewersMap[display] ?: 0) + 1
            addedLocations.add(block.location.toString())
        }

        object : BukkitRunnable() {
            override fun run() {
                for (location in addedLocations) {
                    val display = displayMap[location] ?: continue
                    viewersMap[display] = viewersMap[display]!! - 1
                    if (viewersMap[display]!! > 0) continue
                    viewersMap.remove(display)
                    displayMap.remove(location)
                    display.remove()
                }
            }
        }.runTaskLater(plugin, (duration * 20).toLong())
    }

    internal fun disable() {
        for ((_, display) in displayMap)
            display.remove()
    }
}