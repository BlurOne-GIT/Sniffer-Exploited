package code.blurone.snifferexploited

import org.bukkit.*
import org.bukkit.configuration.ConfigurationSection
import org.bukkit.craftbukkit.v1_20_R3.entity.CraftDisplay
import org.bukkit.entity.*
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.BlockBreakEvent
import org.bukkit.event.entity.AreaEffectCloudApplyEvent
import org.bukkit.event.entity.LingeringPotionSplashEvent
import org.bukkit.event.entity.PotionSplashEvent
import org.bukkit.event.inventory.BrewEvent
import org.bukkit.event.player.PlayerItemConsumeEvent
import org.bukkit.inventory.ItemFlag
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.PotionMeta
import org.bukkit.persistence.PersistentDataType
import org.bukkit.plugin.java.JavaPlugin
import org.bukkit.potion.PotionEffect
import org.bukkit.potion.PotionEffectType
import org.bukkit.scheduler.BukkitRunnable
import org.bukkit.scheduler.BukkitTask
import org.bukkit.util.Transformation
import org.joml.Vector3f
import java.util.*

class PotionOfSniffing(private val plugin: JavaPlugin, config: ConfigurationSection) : Listener {
    companion object {
        fun isSniffingPotion (itemStack: ItemStack): Boolean {
            return (itemStack.type == Material.POTION || itemStack.type == Material.SPLASH_POTION || itemStack.type == Material.LINGERING_POTION) && itemStack.itemMeta!!.persistentDataContainer.has(sniffingPotionNamespacedKey)
        }

        fun createPotion(potionVariant: String = "potion"): ItemStack
        {
            return createPotion(when(potionVariant)
            {
                "splash" -> 1
                "lingering" -> 2
                else -> 0
            })
        }

        private fun createPotion(potionVariant: Int = 0): ItemStack
        {
            val potion = ItemStack(when(potionVariant)
            {
                1 -> Material.SPLASH_POTION
                2 -> Material.LINGERING_POTION
                else -> Material.POTION
            })
            val meta = potion.itemMeta as PotionMeta
            meta.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, potionVariant)
            meta.setDisplayName("ยงr${when(potionVariant)
            {
                1 -> OcdTranslator.DEFAULT_SPLASH_NAME
                2 -> OcdTranslator.DEFAULT_LINGERING_NAME
                else -> OcdTranslator.DEFAULT_POTION_NAME
            }}")
            meta.lore = listOf("ยง9${OcdTranslator.DEFAULT_INFO}")
            meta.color = Color.fromRGB(0xffbf23)
            meta.addItemFlags(ItemFlag.HIDE_POTION_EFFECTS)
            meta.setCustomModelData(customModelData)
            potion.itemMeta = meta
            return potion
        }

        private lateinit var sniffingPotionNamespacedKey : NamespacedKey
        private var customModelData : Int? = null
    }

    init {
        sniffingPotionNamespacedKey = NamespacedKey(plugin, "sniffing_potion")
        customModelData = config.get("custom_model_data") as? Int
    }

    private val playerMaps = mutableMapOf<Player, MutableMap<Location, Display>>()
    private val taskMap = mutableMapOf<UUID, BukkitTask>()
    private val shallLog = config.getBoolean("sniff_logging", true)
    private val oreSniffingMode = config.getString("ore_sniffing_mode", "block")
    private val worlds = config.getConfigurationSection("enabled_worlds")

    @EventHandler
    private fun drinkSniffingPotionEvent(event: PlayerItemConsumeEvent)
    {
        if (isSniffingPotion(event.item))
            scanForOres(event.player)
    }

    @EventHandler
    private fun splashingSniffingPotionEvent(event: PotionSplashEvent)
    {
        if (!isSniffingPotion(event.potion.item)) return

        for (entity in event.affectedEntities)
        {
            val intensity = event.getIntensity(entity)
            if (entity !is Player)
            {
                entity.world.playSound(entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, (1.5 - 0.25 * intensity).toFloat())
                continue
            }
            scanForOres(entity, ((worlds?.getInt("${entity.world.name}.radius") ?: 16)*intensity).toInt())
        }
    }

    @EventHandler
    private fun lingeringSniffingCloudCreateEvent(event: LingeringPotionSplashEvent)
    {
        if (!isSniffingPotion(event.entity.item)) return

        event.areaEffectCloud.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, 2)
        event.areaEffectCloud.addCustomEffect(PotionEffect(PotionEffectType.LUCK, 0, 1, false, false, false), true)
        event.areaEffectCloud.color = Color.fromRGB(0xffbf23)
    }

    @EventHandler
    private fun areaCloudSniffingEvent(event: AreaEffectCloudApplyEvent)
    {
        if (!event.entity.persistentDataContainer.has(sniffingPotionNamespacedKey))
            return

        for (entity in event.affectedEntities)
        {
            if (entity !is Player)
            {
                entity.world.playSound(entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, 1.5f)
                continue
            }
            scanForOres(entity, duration = (worlds?.getDouble("${entity.world.name}.duration") ?: 60.0)*0.25)
        }
    }

    @EventHandler
    private fun brewSniffingPotionUpgradeEvent(event: BrewEvent)
    {
        val lookingForLevel = when (event.contents.ingredient?.type)
        {
            Material.GUNPOWDER -> 0
            Material.DRAGON_BREATH -> 1
            else -> return
        }

        for (i in 0..<event.contents.contents.size)
            if (event.contents.contents[i] != null && event.contents.contents[i].itemMeta!!.persistentDataContainer.get(sniffingPotionNamespacedKey, PersistentDataType.INTEGER) == lookingForLevel)
                event.results[i].itemMeta = createPotion(lookingForLevel + 1).itemMeta
    }

    @EventHandler
    private fun killDisplayEvent(event: BlockBreakEvent)
    {
        if (playerMaps.isEmpty() || !playerMaps.values.any { it.containsKey(event.block.location) }) return

        for (playerMap in playerMaps.values)
            playerMap.remove(event.block.location)?.remove()
    }

    fun scanForOres(player: Player, radius: Int = worlds?.getInt("${player.world.name}.radius") ?: 16, duration: Double = worlds?.getDouble("${player.world.name}.duration") ?: 60.0)
    {
        if (radius <= 1) return

        if (shallLog)
            plugin.logger.info("${player.name} is sniffing for ores in a radius of $radius blocks for $duration seconds.")

        player.world.playSound(player, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, (1.25 - 0.25 * radius / (worlds?.getInt("${player.world.name}.radius") ?: 16)).toFloat())

        for (x in -radius..radius)
            for (y in -radius..radius)
                for (z in -radius..radius)
                {
                    val location = Location(player.world,
                        (player.location.blockX + x).toDouble(),
                        (player.location.blockY + y).toDouble(),
                        (player.location.blockZ + z).toDouble()
                    )
                    val block = player.world.getBlockAt(location)
                    if ((!block.type.name.contains("ORE") && block.type != Material.ANCIENT_DEBRIS && block.type != Material.BUDDING_AMETHYST) || block.type == Material.SPORE_BLOSSOM)
                        continue

                    val display: Display
                    if (oreSniffingMode == "block")
                    {
                        display = player.world.spawnEntity(location, EntityType.BLOCK_DISPLAY, false) as BlockDisplay
                        display.transformation = Transformation(
                            Vector3f(0.001f, 0.001f, 0.001f),
                            display.transformation.leftRotation,
                            Vector3f(0.998f, 0.998f, 0.998f),
                            display.transformation.rightRotation
                        )
                        display.block = block.blockData
                    } else {
                        display = player.world.spawnEntity(location.clone().add(0.5, 0.5, 0.5), EntityType.ITEM_DISPLAY, false) as ItemDisplay
                        val raw = oreSniffingMode == "raw"
                        display.billboard = Display.Billboard.CENTER
                        display.itemStack = ItemStack(when (block.type)
                        {
                            Material.COAL_ORE,
                            Material.DEEPSLATE_COAL_ORE -> Material.COAL
                            Material.IRON_ORE,
                            Material.DEEPSLATE_IRON_ORE -> if (raw) Material.RAW_IRON else Material.IRON_INGOT
                            Material.COPPER_ORE,
                            Material.DEEPSLATE_COPPER_ORE -> if (raw) Material.RAW_COPPER else Material.COPPER_INGOT
                            Material.GOLD_ORE,
                            Material.DEEPSLATE_GOLD_ORE -> if (raw) Material.RAW_GOLD else Material.GOLD_INGOT
                            Material.NETHER_GOLD_ORE -> Material.GOLD_NUGGET
                            Material.REDSTONE_ORE,
                            Material.DEEPSLATE_REDSTONE_ORE -> Material.REDSTONE
                            Material.EMERALD_ORE,
                            Material.DEEPSLATE_EMERALD_ORE -> Material.EMERALD
                            Material.LAPIS_ORE,
                            Material.DEEPSLATE_LAPIS_ORE -> Material.LAPIS_LAZULI
                            Material.DIAMOND_ORE,
                            Material.DEEPSLATE_DIAMOND_ORE -> Material.DIAMOND
                            Material.NETHER_QUARTZ_ORE -> Material.QUARTZ
                            Material.ANCIENT_DEBRIS -> if (raw) Material.NETHERITE_SCRAP else Material.NETHERITE_INGOT
                            Material.BUDDING_AMETHYST -> Material.AMETHYST_SHARD
                            else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                        })
                    }
                    display.displayHeight = 1f
                    display.displayWidth = 1f
                    display.isGlowing = true
                    display.isVisibleByDefault = false
                    player.showEntity(plugin, display)
                    display.glowColorOverride = when(block.type)
                    {
                        Material.COAL_ORE,
                        Material.DEEPSLATE_COAL_ORE -> Color.fromRGB(0x2e2e2e)
                        Material.IRON_ORE,
                        Material.DEEPSLATE_IRON_ORE -> Color.fromRGB(0xd8af93)
                        Material.COPPER_ORE,
                        Material.DEEPSLATE_COPPER_ORE -> Color.fromRGB(0xe0734d)
                        Material.GOLD_ORE,
                        Material.DEEPSLATE_GOLD_ORE,
                        Material.NETHER_GOLD_ORE -> Color.fromRGB(0xeb9d0e)
                        Material.REDSTONE_ORE,
                        Material.DEEPSLATE_REDSTONE_ORE -> Color.fromRGB(0xff0000)
                        Material.EMERALD_ORE,
                        Material.DEEPSLATE_EMERALD_ORE -> Color.fromRGB(0x17dd62)
                        Material.LAPIS_ORE,
                        Material.DEEPSLATE_LAPIS_ORE -> Color.fromRGB(0x1855bd)
                        Material.DIAMOND_ORE,
                        Material.DEEPSLATE_DIAMOND_ORE -> Color.fromRGB(0x77e7d1)
                        Material.NETHER_QUARTZ_ORE -> Color.fromRGB(0xeae5de)
                        Material.ANCIENT_DEBRIS -> Color.fromRGB(0x654740)
                        Material.BUDDING_AMETHYST -> Color.fromRGB(0xa678f1)
                        else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                    }
                    (display as CraftDisplay).handle.persistentInvisibility = true //Force invisible
                    display.handle.setSharedFlag(5, true) //Force invisible

                    if(!playerMaps.containsKey(player))
                        playerMaps[player] = mutableMapOf()

                    // .let my beloved
                    playerMaps[player]!![location]?.let {
                        taskMap.remove(it.uniqueId)!!.cancel()
                        it.remove()
                    }

                    playerMaps[player]!![location] = display
                    taskMap[display.uniqueId] = object : BukkitRunnable()
                    {
                        override fun run() {
                            playerMaps[player]!!.remove(location)?.remove()
                        }
                    }.runTaskLater(plugin, (duration * 20).toLong())
                }
    }

    internal fun disable()
    {
        for (playerMap in playerMaps.values)
            for (display in playerMap.values)
                display.remove()
    }
}