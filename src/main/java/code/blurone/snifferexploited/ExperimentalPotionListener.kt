/* Broken due to nms updates
package code.blurone.snifferexploited

import net.minecraft.world.level.block.entity.BrewingStandBlockEntity
import org.bukkit.Material
import org.bukkit.craftbukkit.v1_20_R3.block.CraftBlockEntityState
import org.bukkit.craftbukkit.v1_20_R3.block.CraftBrewingStand
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.block.BrewingStartEvent
import org.bukkit.event.inventory.BrewEvent
import org.bukkit.inventory.meta.PotionMeta
import org.bukkit.potion.PotionData
import org.bukkit.potion.PotionEffect
import org.bukkit.potion.PotionEffectType
import org.bukkit.potion.PotionType
import java.util.logging.Logger

// I'll make this into a library plugin with an API
class ExperimentalPotionListener(private val logger: Logger) : Listener {
    //val craftMetaPotionClass = Class.forName("org.bukkit.craftbukkit.v1_20_R1.inventory.CraftMetaPotion")
    private val tileEntityField = CraftBlockEntityState::class.java.getDeclaredField("tileEntity")
    /*private val potionTypeConstructor = PotionType::class.java.declaredConstructors[0]
    private val constructorAccessor: ConstructorAccessor*/
    private val ptEffectField = PotionType::class.java.getDeclaredField("effect")
    private val ptUpgradeableField = PotionType::class.java.getDeclaredField("upgradeable")
    private val ptExtendableField = PotionType::class.java.getDeclaredField("extendable")
    private val invertiblePotions = listOf(
        PotionType.SPEED,
        PotionType.JUMP,
        PotionType.INSTANT_HEAL,
        PotionType.POISON,
        PotionType.NIGHT_VISION,
        PotionType.WATER
    )

    private val fromAwkward: MutableMap<Material, CustomPotionType> = mutableMapOf()

    init {
        tileEntityField.isAccessible = true
        ptEffectField.isAccessible = true
        ptUpgradeableField.isAccessible = true
        ptExtendableField.isAccessible = true

        /*
        potionTypeConstructor.isAccessible = true

        val constructorAccessorField = Constructor::class.java.getDeclaredField("constructorAccessor")
        constructorAccessorField.isAccessible = true

        var constructor: Any

        var ca = constructorAccessorField[potionTypeConstructor] as ConstructorAccessor?
        if (ca == null) {
            val acquireConstructorAccessorMethod: Method = Constructor::class.java.getDeclaredMethod("acquireConstructorAccessor")
            acquireConstructorAccessorMethod.isAccessible = true
            ca = acquireConstructorAccessorMethod.invoke(potionTypeConstructor) as ConstructorAccessor
        }
        constructorAccessor = ca
         */
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    fun brewStartEvent(event: BrewingStartEvent)
    {
        logger.info("Brewing start event")
        val inventory = (event.block.state as CraftBrewingStand).inventory

        if (inventory.contents.none { (it?.itemMeta as? PotionMeta)?.basePotionData?.type == PotionType.UNCRAFTABLE }) return

        when (inventory.ingredient?.type)
        {
            Material.REDSTONE -> if (inventory.contents.any { (it?.itemMeta as? PotionMeta)?.basePotionData?.type?.isExtendable == true &&
            (it.itemMeta as? PotionMeta)?.basePotionData?.isExtended == false})
                return
            Material.GLOWSTONE_DUST -> if (inventory.contents.any {(it?.itemMeta as? PotionMeta)?.basePotionData?.type?.isUpgradeable == true &&
            (it.itemMeta as? PotionMeta)?.basePotionData?.isUpgraded == false})
                return
            Material.FERMENTED_SPIDER_EYE -> if (inventory.contents.any { invertiblePotions.contains((it?.itemMeta as? PotionMeta)?.basePotionData?.type) ||
            (it?.itemMeta as? PotionMeta)?.basePotionData?.type?.effectType == PotionEffectType.GLOWING ||
            (it?.itemMeta as? PotionMeta)?.basePotionData?.type?.effectType == PotionEffectType.HUNGER } )
                return
            else -> return
        }
        forceCancelStartEvent(event.block.state as CraftBrewingStand)
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    fun brewFinishEvent(event: BrewEvent)
    {
        if (event.results.none {
            val rar = (it?.itemMeta as? PotionMeta)?.basePotionData?.type
            val bul = rar == PotionType.UNCRAFTABLE
            logger.info("$rar")
            logger.info("Brewing finish event: $bul")
            bul
        }) return

        logger.info("${event.contents.ingredient?.type}")

        for (i in 0..2)
        {
            if ((event.results[i]?.itemMeta as? PotionMeta)?.basePotionData?.type != PotionType.UNCRAFTABLE) continue

            val meta = (event.contents.contents[i].itemMeta as? PotionMeta) ?: continue

            val effect = meta.basePotionData.type.effectType
            val isExtendable = meta.basePotionData.type.isExtendable
            val isUpgradeable = meta.basePotionData.type.isUpgradeable
            val isLong = meta.basePotionData.isExtended
            val isStrong = meta.basePotionData.isUpgraded

            logger.info("""
            Effect: $effect
            Extendable: $isExtendable
            Upgradeable: $isUpgradeable
            Long: $isLong
            Strong: $isStrong
            """.trimIndent())

            when (event.contents.ingredient?.type)
            {
                Material.REDSTONE -> if (isExtendable && !isLong && !isStrong) meta.basePotionData = PotionData(meta.basePotionData.type, true, false)
                Material.GLOWSTONE_DUST -> if (isUpgradeable && !isStrong && !isLong) meta.basePotionData = PotionData(meta.basePotionData.type, false, true)
                Material.TORCHFLOWER -> meta.basePotionData = PotionData(createPotionType(PotionEffectType.GLOWING, false, true))
                Material.PITCHER_PLANT -> meta.basePotionData = PotionData(createPotionType(PotionEffectType.HUNGER, true, true))
                Material.FERMENTED_SPIDER_EYE -> when (effect)
                {
                    PotionEffectType.GLOWING -> meta.basePotionData = PotionData(createPotionType(PotionEffectType.DARKNESS, false, true), isLong, isStrong)
                    PotionEffectType.HUNGER -> meta.basePotionData = PotionData(createPotionType(PotionEffectType.SATURATION, true, true), isLong, isStrong)
                    else -> continue
                }
                else -> return
            }

            meta.

            meta.addCustomEffect(PotionEffect(PotionEffectType.ABSORPTION))

            event.results[i].itemMeta = meta
        }
    }

    private fun createPotionType(effect: PotionEffectType, upgradeable: Boolean, extendable: Boolean): PotionType
    {
        val baseType = PotionType.UNCRAFTABLE
        ptEffectField[baseType] = effect
        ptUpgradeableField[baseType] = upgradeable
        ptExtendableField[baseType] = extendable

        logger.info("""
            Logging PotionType.UNCRAFTABLE for possible corruption:
            ${PotionType.UNCRAFTABLE.effectType?.name}
            ${PotionType.UNCRAFTABLE.isUpgradeable}
            ${PotionType.UNCRAFTABLE.isExtendable}
        """.trimIndent())

        return baseType
    }

    private fun forceCancelStartEvent(block: CraftBrewingStand)
    {
        val brewingStandBlockEntity = tileEntityField.get(block as CraftBlockEntityState<BrewingStandBlockEntity>) as BrewingStandBlockEntity
        brewingStandBlockEntity.brewTime = 0
    }

    private data class CustomPotionType(
        val effectType: PotionEffect,
        val isUpgradeable: Boolean,
        val isExtendable: Boolean
    )
}
*/