package code.blurone.snifferexploited

import net.minecraft.world.level.block.state.BlockState
import org.apache.commons.lang.UnhandledException
import org.bukkit.*
import org.bukkit.craftbukkit.v1_20_R1.entity.CraftBlockDisplay
import org.bukkit.craftbukkit.v1_20_R1.entity.CraftDisplay
import org.bukkit.craftbukkit.v1_20_R1.entity.CraftPlayer
import org.bukkit.craftbukkit.v1_20_R1.entity.CraftShulker
import org.bukkit.craftbukkit.v1_20_R1.entity.CraftSniffer
import org.bukkit.entity.BlockDisplay
import org.bukkit.entity.EntityType
import org.bukkit.entity.Player
import org.bukkit.entity.Shulker
import org.bukkit.entity.Sniffer
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.block.Action
import org.bukkit.event.block.BlockBreakEvent
import org.bukkit.event.block.BlockPlaceEvent
import org.bukkit.event.player.PlayerInteractEntityEvent
import org.bukkit.event.player.PlayerInteractEvent
import org.bukkit.inventory.EquipmentSlot
import org.bukkit.inventory.meta.SkullMeta
import org.bukkit.metadata.FixedMetadataValue
import org.bukkit.plugin.java.JavaPlugin
import org.bukkit.scheduler.BukkitRunnable
import org.bukkit.util.Transformation
import org.joml.Quaternionf
import org.joml.Vector3f

class SnifferExploited : JavaPlugin(), Listener {

    private val map = mutableMapOf<Location, BlockDisplay>()

    override fun onEnable() {
        // Plugin startup logic
        server.pluginManager.registerEvents(this, this)
    }

    override fun onDisable() {
        // Plugin shutdown logic
    }

    @EventHandler
    fun playerInteractEvent(event: PlayerInteractEntityEvent)
    {
        if (event.rightClicked.type != EntityType.SNIFFER || event.player.gameMode == GameMode.SPECTATOR ||
            (event.hand == EquipmentSlot.HAND && !(event.player.inventory.itemInMainHand.type == Material.SUGAR || event.player.inventory.itemInMainHand.type == Material.LEGACY_SUGAR)) ||
            (event.hand == EquipmentSlot.OFF_HAND && !(event.player.inventory.itemInOffHand.type == Material.SUGAR || event.player.inventory.itemInOffHand.type == Material.LEGACY_SUGAR)))
            return

        if (event.player.gameMode != GameMode.CREATIVE) {
            val sugarStack = if (event.hand == EquipmentSlot.HAND) event.player.inventory.itemInMainHand else event.player.inventory.itemInOffHand
            sugarStack.amount--
        }

        val sniffer = event.rightClicked as CraftSniffer

        if (!sniffer.hasMetadata(highOnSugarMetaName))
        {
            sniffer.handle.goalSelector.removeAllGoals { it.stop(); true }
            sniffer.handle.navigation.stop()
            sniffer.handle.lookAt((event.player as CraftPlayer).handle, 2f, 2f)
            val goal = RunAroundLikeHighOnSugarGoal(sniffer)
            object : BukkitRunnable()
            {
                override fun run() {sniffer.state = Sniffer.State.SNIFFING}
            }.runTaskLater(this, 5)
            object : BukkitRunnable()
            {
                override fun run() {
                    sniffer.handle.goalSelector.addGoal(0, goal)
                    sniffer.handle.goalSelector.availableGoals.first { it.goal == goal }.start()
                }
            }.runTaskLater(this, 25)
            sniffer.setMetadata(highOnSugarMetaName, FixedMetadataValue(this, goal))
        }
        else
        {
            sniffer.state = Sniffer.State.SNIFFING
            (sniffer.getMetadata(highOnSugarMetaName).first().value() as RunAroundLikeHighOnSugarGoal).potentiate()
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    fun cancelSnifferNosePlacementEvent(event: BlockPlaceEvent)
    {
        if (event.itemInHand.type != Material.PLAYER_HEAD) return
        logger.info("it head")

        val skullMeta = event.itemInHand.itemMeta as SkullMeta
        if (skullMeta.hasOwner() && skullMeta.ownerProfile!!.name == snifferNoseName) event.isCancelled = true
        logger.info("it owner ${skullMeta.ownerProfile!!.name}")
        logger.info("it cancelled ${event.isCancelled}")
    }

    @EventHandler(priority = EventPriority.LOWEST)
    fun sniffEvent(event: PlayerInteractEvent)
    {
        if (event.item?.type != Material.PLAYER_HEAD ||
            (event.action != Action.RIGHT_CLICK_AIR &&
            event.action != Action.RIGHT_CLICK_BLOCK)) return

        val skullMeta = event.item!!.itemMeta as SkullMeta
        if (!skullMeta.hasOwner() || skullMeta.ownerProfile!!.name != snifferNoseName) return

        event.item!!.amount--
        event.player.playSound(event.player.location, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 4f, 0.75f)
        scanForOres(event.player, 24)
    }

    @EventHandler
    fun killDisplayEvent(event: BlockBreakEvent)
    {
        if (map.isEmpty() || !map.containsKey(event.block.location)) return

        map[event.block.location]!!.remove()
        map.remove(event.block.location)
    }

    private fun scanForOres(player: Player, range: Int)
    {
        for (x in -range..range)
            for (y in -range..range)
                for (z in -range..range)
                {
                    val location = Location(player.world,
                        (player.location.blockX + x).toDouble(),
                        (player.location.blockY + y).toDouble(),
                        (player.location.blockZ + z).toDouble()
                    )
                    val block = player.world.getBlockAt(location)
                    if (!block.type.name.contains("ORE") && block.type != Material.ANCIENT_DEBRIS)
                        continue

                    val display = player.world.spawnEntity(location, EntityType.BLOCK_DISPLAY, false) as BlockDisplay
                    display.block = block.blockData
                    display.displayHeight = 1f
                    display.displayWidth = 1f
                    display.transformation = Transformation(
                        Vector3f(0.01f, 0.01f, 0.01f),
                        display.transformation.leftRotation,
                        Vector3f(0.98f, 0.98f, 0.98f),
                        display.transformation.rightRotation
                    )
                    display.isGlowing = true
                    display.isVisibleByDefault = false
                    player.showEntity(this, display)
                    display.glowColorOverride = when(block.type)
                    {
                        Material.COAL_ORE,
                        Material.DEEPSLATE_COAL_ORE -> Color.fromRGB(0x2e2e2e)
                        Material.IRON_ORE,
                        Material.DEEPSLATE_IRON_ORE -> Color.fromRGB(0xd8af93)
                        Material.COPPER_ORE,
                        Material.DEEPSLATE_COPPER_ORE -> Color.fromRGB(0xe0734d)
                        Material.GOLD_ORE,
                        Material.DEEPSLATE_GOLD_ORE,
                        Material.NETHER_GOLD_ORE -> Color.fromRGB(0xeb9d0e)
                        Material.REDSTONE_ORE,
                        Material.DEEPSLATE_REDSTONE_ORE -> Color.fromRGB(0xff0000)
                        Material.EMERALD_ORE,
                        Material.DEEPSLATE_EMERALD_ORE -> Color.fromRGB(0x17dd62)
                        Material.LAPIS_ORE,
                        Material.DEEPSLATE_LAPIS_ORE -> Color.fromRGB(0x1855bd)
                        Material.DIAMOND_ORE,
                        Material.DEEPSLATE_DIAMOND_ORE -> Color.fromRGB(0x77e7d1)
                        Material.NETHER_QUARTZ_ORE -> Color.fromRGB(0xeae5de)
                        Material.ANCIENT_DEBRIS -> Color.fromRGB(0x654740)
                        else -> throw UnhandledException(Throwable("Unhandled ore type ${block.type}"))
                    }
                    (display as CraftBlockDisplay).handle.persistentInvisibility = true //Force invisible
                    display.handle.setSharedFlag(5, true) //Force invisible

                    map[location] = display
                    object : BukkitRunnable()
                    {
                        override fun run() {
                            display.remove()
                            map.remove(location)
                        }
                    }.runTaskLater(this, 1200)
                }
    }
}
