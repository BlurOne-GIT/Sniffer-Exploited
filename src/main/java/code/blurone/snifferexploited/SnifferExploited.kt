package code.blurone.snifferexploited

/*
import net.minecraft.core.MappedRegistry
import net.minecraft.core.Registry
import net.minecraft.core.registries.BuiltInRegistries
import net.minecraft.world.effect.MobEffectInstance
import net.minecraft.world.effect.MobEffects
import net.minecraft.world.item.Item
import net.minecraft.world.item.Items
import net.minecraft.world.item.alchemy.Potion
import net.minecraft.world.item.alchemy.PotionBrewing
import net.minecraft.world.item.alchemy.Potions
*/
import org.bukkit.*
import org.bukkit.craftbukkit.v1_20_R3.entity.CraftDisplay
import org.bukkit.craftbukkit.v1_20_R3.entity.CraftSniffer
import org.bukkit.entity.*
import org.bukkit.event.EventHandler
import org.bukkit.event.Listener
import org.bukkit.event.block.BlockBreakEvent
import org.bukkit.event.entity.AreaEffectCloudApplyEvent
import org.bukkit.event.entity.LingeringPotionSplashEvent
import org.bukkit.event.entity.PotionSplashEvent
import org.bukkit.event.inventory.BrewEvent
import org.bukkit.event.player.PlayerInteractEntityEvent
import org.bukkit.event.player.PlayerItemConsumeEvent
import org.bukkit.event.player.PlayerTeleportEvent
import org.bukkit.inventory.EquipmentSlot
import org.bukkit.inventory.ItemFlag
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.PotionMeta
import org.bukkit.metadata.FixedMetadataValue
import org.bukkit.persistence.PersistentDataType
import org.bukkit.plugin.java.JavaPlugin
import org.bukkit.potion.PotionEffect
import org.bukkit.potion.PotionEffectType
import org.bukkit.scheduler.BukkitRunnable
import org.bukkit.scheduler.BukkitTask
import org.bukkit.util.Transformation
import org.joml.Vector3f
import java.util.*
import kotlin.math.atan2
import kotlin.math.pow
import kotlin.math.sqrt


class SnifferExploited : JavaPlugin(), Listener {

    private val playerMaps = mutableMapOf<Player, MutableMap<Location, Display>>()
    private val taskMap = mutableMapOf<UUID, BukkitTask>()
    private val invincibleSniffers = config.getBoolean("invincibleSniffers", false)
    private val sniffingPotionNamespacedKey = NamespacedKey(this, sniffingPotionKey)
    //private val experimentalPotions = config.getBoolean("experimentalPotions", false)

    override fun onEnable() {
        // Plugin startup logic
        saveDefaultConfig()
        server.pluginManager.registerEvents(this, this)
        timeBeforeExploding = config.getInt("timeBeforeExploding", 4) * 5
        disableExplosion = config.getBoolean("disableExplosion", false)
        minFire = config.getInt("minFire", 2) - 1
        potionDropChance = config.getDouble("potionDropChance", 100.0) * 0.01
        initialSpeed = config.getDouble("initialSpeed", 10.0)

        val pt = config.getConfigurationSection("potionTranslations")
        val st = config.getConfigurationSection("splashTranslations")
        val lt = config.getConfigurationSection("lingeringTranslations")
        val it = config.getConfigurationSection("infoTranslations")

        if (pt != null && st != null && lt != null && it != null && !config.getBoolean("disableTranslations", false))
            server.pluginManager.registerEvents(OcdTranslator(pt, st, lt, it, sniffingPotionNamespacedKey), this)

        val fscc = config.getDouble("findSlimeChunksChance", 100.0)
        if (fscc != 0.0)
            server.pluginManager.registerEvents(SlimeChunkSniffer(fscc), this)

        /* Broken due to nms updates
        if (!experimentalPotions) return

        server.pluginManager.registerEvents(ExperimentalPotionListener(logger), this)

        /*
        //val wereAccessible: MutableList<Boolean> = mutableListOf()

        // Unfreeze registry
        val frozenField = MappedRegistry::class.java.getDeclaredField("l") //l -> frozen: Boolean
        wereAccessible.add(frozenField.isAccessible)
        frozenField.isAccessible = true
        frozenField.set(BuiltInRegistries.POTION, false)*/

        // Register potions
        val addMixMethod = PotionBrewing().javaClass.getDeclaredMethod("a", Potion::class.java, Item::class.java, Potion::class.java)
        val ammWasAccessible = addMixMethod.isAccessible
        addMixMethod.isAccessible = true

        /*
        val hungerPotion = Registry.register(BuiltInRegistries.POTION, "hunger", Potion("hunger", MobEffectInstance(MobEffects.HUNGER, 900))) as Potion
        val longHungerPotion = Registry.register(BuiltInRegistries.POTION, "long_hunger", Potion("hunger", MobEffectInstance(MobEffects.HUNGER, 1800))) as Potion
        val strongHungerPotion = Registry.register(BuiltInRegistries.POTION, "strong_hunger", Potion("hunger", MobEffectInstance(MobEffects.HUNGER, 450, 1))) as Potion

        val glowingPotion = Registry.register(BuiltInRegistries.POTION, "glowing", Potion("glowing", MobEffectInstance(MobEffects.GLOWING, 1800))) as Potion
        val longGlowingPotion = Registry.register(BuiltInRegistries.POTION, "long_glowing", Potion("glowing", MobEffectInstance(MobEffects.GLOWING, 4800))) as Potion

        addMixMethod.invoke(PotionBrewing(), Potions.AWKWARD, Items.PITCHER_PLANT, hungerPotion)
        addMixMethod.invoke(PotionBrewing(), hungerPotion, Items.REDSTONE, longHungerPotion)
        addMixMethod.invoke(PotionBrewing(), hungerPotion, Items.GLOWSTONE_DUST, strongHungerPotion)

        addMixMethod.invoke(PotionBrewing(), Potions.AWKWARD, Items.TORCHFLOWER, glowingPotion)
        addMixMethod.invoke(PotionBrewing(), glowingPotion, Items.REDSTONE, longGlowingPotion)
         */

        addMixMethod.invoke(PotionBrewing(), Potions.AWKWARD, Items.PITCHER_PLANT, Potions.EMPTY)
        addMixMethod.invoke(PotionBrewing(), Potions.AWKWARD, Items.TORCHFLOWER, Potions.EMPTY)
        addMixMethod.invoke(PotionBrewing(), Potions.EMPTY, Items.REDSTONE, Potions.EMPTY)
        addMixMethod.invoke(PotionBrewing(), Potions.EMPTY, Items.GLOWSTONE_DUST, Potions.EMPTY)
        addMixMethod.invoke(PotionBrewing(), Potions.EMPTY, Items.FERMENTED_SPIDER_EYE, Potions.EMPTY)

        /*
        // Refreeze registry
        BuiltInRegistries.POTION.freeze()
        addMixMethod.isAccessible = wereAccessible.removeLast()
        frozenField.isAccessible = wereAccessible.removeLast()*/
        addMixMethod.isAccessible = ammWasAccessible
        */
    }

    override fun onDisable() {
        // Plugin shutdown logic
        for (playerMap in playerMaps.values) {
            playerMap.values.forEach { it.remove() }
        }
    }

    @EventHandler
    fun playerInteractEvent(event: PlayerInteractEntityEvent)
    {
        if (event.rightClicked.type != EntityType.SNIFFER || event.player.gameMode == GameMode.SPECTATOR ||
            (event.hand == EquipmentSlot.HAND && !(event.player.inventory.itemInMainHand.type == Material.SUGAR || event.player.inventory.itemInMainHand.type == Material.LEGACY_SUGAR)) ||
            (event.hand == EquipmentSlot.OFF_HAND && !(event.player.inventory.itemInOffHand.type == Material.SUGAR || event.player.inventory.itemInOffHand.type == Material.LEGACY_SUGAR)))
            return

        val sugarStack = if (event.hand == EquipmentSlot.HAND) event.player.inventory.itemInMainHand else event.player.inventory.itemInOffHand

        val sniffer = event.rightClicked as CraftSniffer

        if (sniffer.hasMetadata(highOnSugarMetaName))
        {
            val ralhosGoal = sniffer.getMetadata(highOnSugarMetaName).first().value() as RunAroundLikeHighOnSugarGoal
            ralhosGoal.potentiate()
            if (!ralhosGoal.started) return

            sniffer.state = Sniffer.State.SNIFFING
            sniffer.handle.sniffingAnimationState.startIfStopped(sniffer.handle.tickCount)
            if (event.player.gameMode != GameMode.CREATIVE) sugarStack.amount--

            return
        }

        if (invincibleSniffers)
            sniffer.isInvulnerable = true
        sniffer.handle.goalSelector.removeAllGoals { it.stop(); true }
        sniffer.handle.navigation.stop()
        sniffer.teleport(sniffer.location.apply {
            yaw = Math.toDegrees(
                atan2(
                    event.player.location.z - sniffer.location.z, event.player.location.x - sniffer.location.x
                )
            ).toFloat() - 90

            pitch = Math.toDegrees(
                -atan2(
                    event.player.eyeLocation.y - sniffer.eyeLocation.y,
                    sqrt(
                        (event.player.location.x - sniffer.location.x).pow(2) + (event.player.location.z - sniffer.location.z).pow(2)
                    )
                )
            ).toFloat()
        }, PlayerTeleportEvent.TeleportCause.PLUGIN)
        sniffer.handle.setYBodyRot(sniffer.handle.yHeadRot)
        val goal = RunAroundLikeHighOnSugarGoal(sniffer, sniffingPotionNamespacedKey)
        object : BukkitRunnable()
        {
            override fun run() {
                sniffer.state = Sniffer.State.SNIFFING
                sniffer.handle.sniffingAnimationState.startIfStopped(sniffer.handle.tickCount)
                if (event.player.gameMode != GameMode.CREATIVE) sugarStack.amount--
            }
        }.runTaskLater(this, 10)
        object : BukkitRunnable()
        {
            override fun run() {
                sniffer.handle.goalSelector.addGoal(0, goal)
                sniffer.handle.goalSelector.availableGoals.first { it.goal == goal }.start()
            }
        }.runTaskLater(this, 30)
        sniffer.setMetadata(highOnSugarMetaName, FixedMetadataValue(this, goal))
    }

    @EventHandler
    fun drinkSniffingPotionEvent(event: PlayerItemConsumeEvent)
    {
        if (isSniffingPotion(event.item, sniffingPotionNamespacedKey))
            scanForOres(event.player)
    }

    @EventHandler
    fun splashingSniffingPotionEvent(event: PotionSplashEvent)
    {
        if (!isSniffingPotion(event.potion.item, sniffingPotionNamespacedKey)) return

        for (entity in event.affectedEntities)
        {
            val intensity = event.getIntensity(entity)
            if (entity !is Player)
            {
                entity.world.playSound(entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, (2.0 - 0.5 * intensity).toFloat())
                continue
            }
            scanForOres(entity, event.getIntensity(entity))
        }
    }

    @EventHandler
    fun lingeringSniffingCloudCreateEvent(event: LingeringPotionSplashEvent)
    {
        if (!isSniffingPotion(event.entity.item, sniffingPotionNamespacedKey)) return

        event.areaEffectCloud.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, 2)
        event.areaEffectCloud.addCustomEffect(PotionEffect(PotionEffectType.LUCK, 0, 1, false, false, false), true)
        event.areaEffectCloud.color = Color.fromRGB(0xffbf23)
    }

    @EventHandler
    fun areaCloudSniffingEvent(event: AreaEffectCloudApplyEvent)
    {
        if (!event.entity.persistentDataContainer.has(sniffingPotionNamespacedKey))
            return

        for (entity in event.affectedEntities)
        {
            if (entity !is Player)
            {
                entity.world.playSound(entity, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, 2f)
                continue
            }
            scanForOres(entity, isLingering = true)
        }
    }

    @EventHandler
    fun brewSniffingPotionUpgradeEvent(event: BrewEvent)
    {
        if (event.contents.ingredient?.type != Material.GUNPOWDER &&
            event.contents.ingredient?.type != Material.DRAGON_BREATH
            ) return

        val lookingForLevel = if (event.contents.ingredient!!.type == Material.GUNPOWDER) 0 else 1
        for (i in 0..<event.contents.contents.size)
        {
            if (event.contents.contents[i] == null || event.contents.contents[i].itemMeta!!.persistentDataContainer.get(sniffingPotionNamespacedKey, PersistentDataType.INTEGER) != lookingForLevel)
                continue

            val meta = event.results[i].itemMeta!! as PotionMeta
            meta.persistentDataContainer.set(sniffingPotionNamespacedKey, PersistentDataType.INTEGER, lookingForLevel + 1)
            meta.setDisplayName("§r${if (lookingForLevel == 0) defaultSplashName else defaultLingeringName}")
            meta.lore = listOf("§9$defaultPotionInfo")
            meta.color = Color.fromRGB(0xffbf23)
            meta.addItemFlags(ItemFlag.HIDE_POTION_EFFECTS)
            event.results[i].itemMeta = meta
        }
    }

    @EventHandler
    fun killDisplayEvent(event: BlockBreakEvent)
    {
        if (playerMaps.isEmpty() || !playerMaps.values.any { it.containsKey(event.block.location) }) return

        for (playerMap in playerMaps.values)
            playerMap.remove(event.block.location)?.remove()
    }

    private fun scanForOres(player: Player, rangeMultiplier: Double = 1.0, isLingering: Boolean = false)
    {
        val range = (config.getInt("oreSniffingRanges.${player.world.name}", 16) * rangeMultiplier).toInt()
        if (range <= 1) return
        player.world.playSound(player, Sound.ENTITY_SNIFFER_SNIFFING, SoundCategory.PLAYERS, 5f, (1.25 - 0.5 * rangeMultiplier).toFloat())
        for (x in -range..range)
            for (y in -range..range)
                for (z in -range..range)
                {
                    val location = Location(player.world,
                        (player.location.blockX + x).toDouble(),
                        (player.location.blockY + y).toDouble(),
                        (player.location.blockZ + z).toDouble()
                    )
                    val block = player.world.getBlockAt(location)
                    if ((!block.type.name.contains("ORE") && block.type != Material.ANCIENT_DEBRIS && block.type != Material.BUDDING_AMETHYST) || block.type == Material.SPORE_BLOSSOM)
                        continue

                    val display: Display
                    if (config.getString("oreSniffingMode", "block") == "block")
                    {
                        display = player.world.spawnEntity(location, EntityType.BLOCK_DISPLAY, false) as BlockDisplay
                        display.transformation = Transformation(
                            Vector3f(0.001f, 0.001f, 0.001f),
                            display.transformation.leftRotation,
                            Vector3f(0.998f, 0.998f, 0.998f),
                            display.transformation.rightRotation
                        )
                        display.block = block.blockData
                    } else {
                        display = player.world.spawnEntity(location.clone().add(0.5, 0.5, 0.5), EntityType.ITEM_DISPLAY, false) as ItemDisplay
                        val raw = config.getBoolean("rawMineralsForItem", false)
                        display.billboard = Display.Billboard.CENTER
                        display.itemStack = ItemStack(when (block.type)
                        {
                            Material.COAL_ORE,
                            Material.DEEPSLATE_COAL_ORE -> Material.COAL
                            Material.IRON_ORE,
                            Material.DEEPSLATE_IRON_ORE -> if (raw) Material.RAW_IRON else Material.IRON_INGOT
                            Material.COPPER_ORE,
                            Material.DEEPSLATE_COPPER_ORE -> if (raw) Material.RAW_COPPER else Material.COPPER_INGOT
                            Material.GOLD_ORE,
                            Material.DEEPSLATE_GOLD_ORE -> if (raw) Material.RAW_GOLD else Material.GOLD_INGOT
                            Material.NETHER_GOLD_ORE -> Material.GOLD_NUGGET
                            Material.REDSTONE_ORE,
                            Material.DEEPSLATE_REDSTONE_ORE -> Material.REDSTONE
                            Material.EMERALD_ORE,
                            Material.DEEPSLATE_EMERALD_ORE -> Material.EMERALD
                            Material.LAPIS_ORE,
                            Material.DEEPSLATE_LAPIS_ORE -> Material.LAPIS_LAZULI
                            Material.DIAMOND_ORE,
                            Material.DEEPSLATE_DIAMOND_ORE -> Material.DIAMOND
                            Material.NETHER_QUARTZ_ORE -> Material.QUARTZ
                            Material.ANCIENT_DEBRIS -> if (raw) Material.NETHERITE_SCRAP else Material.NETHERITE_INGOT
                            Material.BUDDING_AMETHYST -> Material.AMETHYST_SHARD
                            else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                        })
                    }
                    display.displayHeight = 1f
                    display.displayWidth = 1f
                    display.isGlowing = true
                    display.isVisibleByDefault = false
                    player.showEntity(this, display)
                    display.glowColorOverride = when(block.type)
                    {
                        Material.COAL_ORE,
                        Material.DEEPSLATE_COAL_ORE -> Color.fromRGB(0x2e2e2e)
                        Material.IRON_ORE,
                        Material.DEEPSLATE_IRON_ORE -> Color.fromRGB(0xd8af93)
                        Material.COPPER_ORE,
                        Material.DEEPSLATE_COPPER_ORE -> Color.fromRGB(0xe0734d)
                        Material.GOLD_ORE,
                        Material.DEEPSLATE_GOLD_ORE,
                        Material.NETHER_GOLD_ORE -> Color.fromRGB(0xeb9d0e)
                        Material.REDSTONE_ORE,
                        Material.DEEPSLATE_REDSTONE_ORE -> Color.fromRGB(0xff0000)
                        Material.EMERALD_ORE,
                        Material.DEEPSLATE_EMERALD_ORE -> Color.fromRGB(0x17dd62)
                        Material.LAPIS_ORE,
                        Material.DEEPSLATE_LAPIS_ORE -> Color.fromRGB(0x1855bd)
                        Material.DIAMOND_ORE,
                        Material.DEEPSLATE_DIAMOND_ORE -> Color.fromRGB(0x77e7d1)
                        Material.NETHER_QUARTZ_ORE -> Color.fromRGB(0xeae5de)
                        Material.ANCIENT_DEBRIS -> Color.fromRGB(0x654740)
                        Material.BUDDING_AMETHYST -> Color.fromRGB(0xa678f1)
                        else -> throw IllegalArgumentException("Unhandled ore type ${block.type}")
                    }
                    (display as CraftDisplay).handle.persistentInvisibility = true //Force invisible
                    display.handle.setSharedFlag(5, true) //Force invisible

                    if(!playerMaps.containsKey(player))
                        playerMaps[player] = mutableMapOf()

                    // .let my beloved
                    playerMaps[player]!![location]?.let {
                        taskMap.remove(it.uniqueId)!!.cancel()
                        it.remove()
                    }

                    playerMaps[player]!![location] = display
                    taskMap[display.uniqueId] = object : BukkitRunnable()
                        {
                            override fun run() {
                                playerMaps[player]!!.remove(location)?.remove()
                            }
                        }.runTaskLater(this, (config.getDouble("oreSniffingDurations.${player.world.name}", 60.0) * if (!isLingering) 20 else 5).toLong())
                }
    }
}
